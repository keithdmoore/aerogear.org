---
layout: basic
title: Sending messages
---

Now you have the Sample App running on your phone, so it is time to use the _AeroGear UnifiedPush Server_ for delivering a _Push Notification_ message to your device!

== Simple Sender

A bit earlier you received a _pushApplicationID_ and a _masterSecret_ after the successful registration of the _Push Application_. These ID's  are used for sending a _broadcast_ message to all _registered_ devices (installations). Now, on a command line issue the following _CURL_ command:

[source,c]
----
curl -3 -u "{pushApplicationID}:{masterSecret}"
   -v -H "Accept: application/json" -H "Content-type: application/json" 
   -X POST -d '{"message": {"alert":"Hello AeroGear Unified Push!", "badge":1, "customKey":"some value"}}'
   https://SERVER:PORT/CONTEXT/rest/sender
----

The payload is simply a JSON map. You can send different key/value pairs, but be sure it is not too long, otherwise Apple does _NOT_ deliver the message to your phone. The _alert_ key is recognized by the _AeroGear UnifiedPush Server_ and translated into an APNs specific _alert_.


When the application is inactive, and a _Push Notification_ containing the _alert_ key is received by the device, a _Popup_ will show up, which displays the value of the _alert_ key:

image:./img/PushMessage.jpg[iOS Push Notification]


**NOTE:** No custom code for this feature is required. It's build-in to _iOS Platform_.


== Custom Dialog

While the application is running in foreground, the above described feature is _NOT_ available. However, a different callback can be implemented on the _AppDelegate_ class:

[source,c]
----
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo {

    // A JSON object is received, represented as a NSDictionary.
    // use it to pick your custom key
    
    // For demo reasons, we simply read the "alert" key, from the "aps" dictionary:
    NSString *alertValue = [userInfo valueForKeyPath:@"aps.alert"];
    
    
    UIAlertView *alert = [[UIAlertView alloc]
                          initWithTitle: @"Custom Dialog, while Program is active"
                          message: alertValue
                          delegate: nil
                          cancelButtonTitle:@"OK"
                          otherButtonTitles:nil];
    [alert show];
}
----

The _application didReceiveRemoteNotification:_ method receives a _NSDictionary_ which represents a _JSON_ map, of the received payload. The _aps_ field of that map contains all the received attributes, like the earlier mentioned _alert_ key/value pair. The show code simply reads the value of the _alert_ key and explicitly displays it in a custom dialog. Of course, based on the needed functionality it would be also possible to update a view, based on the received message.


The custom Dialog:

image:./img/CustomDialog.jpg[Custom Dialog]

=== Custom Keys

Besides reading the standard keys, like +alert+ the UnifiedPush Server supports custom keys. In the above +curl+ we used the +customKey+, which could have an application specific meaning. Reading the value of your own keys is as simple as in the above snippet about the custom dialog:

[source,c]
----
NSString *customValue = [userInfo valueForKeyPath:@"customKey"];
----

Now the evaluated value can be used inside of the iOS application.

== iOS 7

In iOS 7 there is a new callback which, in addition to the normal foreground processing, allows the application to process messages while it is running in the background.

_Note:_ *If your application has _no_ need for background processing, using the above method is recommended.*

[source,c]
----
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {

    if (application.applicationState == UIApplicationStateBackground) {
        // perform tasks that are best suited for background processing,
        // such as download data that is related to the push notification
        
        ...
        
        // afterwards it is required to invoke the given block:
        completionHandler(UIBackgroundFetchResultNewData); // download of data did succeed
    } else {
        // foreground specific tasks
    }
}
----

Using this method, the iOS platform processes the notification and launches the application in the background. This helps to shrink the time between seeing a push notification and displaying the actual data in the iOS application, as the download of the data for the push notification (if really needed) starts in the background as well.

=== Enabling Background Notifications

In order to get background processing for push notifications to work you have to open your Applications' +Info.plist+ file:

image:./img/InfoPlist.png[Info.plist file of the Application]

and include the following XML:

[source,c]
----
<key>UIBackgroundModes</key>
<array>
    <string>remote-notification</string>
</array>
----

=== Sending Notifications for Background Processing

To ensure that your message is really received by our application when it is in background mode, you need to include +"content-available":true+ into your JSON payload, like:

[source,c]
----

curl -3 -u "{pushApplicationID}:{masterSecret}"
   -v -H "Accept: application/json" -H "Content-type: application/json" 
   -X POST -d '{"message": {"content-available":true, "customKey":"some value"}}'
   https://SERVER:PORT/CONTEXT/rest/sender
----
== iOS 8

iOS 8 provides support for interactive notifications. To utilise it, follow these steps:

* add extra payload +"action-category"+ in server side notification
* add category in your client app with the same name as the one in payload 
* add action button logic

If you want a complete example that demo's interactive notification refer to link:https://github.com/aerogear/aerogear-aerodoc-ios/[AeroDoc].

=== Sending interactive notifications : extra payload

All you need to do is include +"action-category":"YOUR_ACTION_NAME"+ into your JSON payload like:

[source,c]
----

curl -3 -u "{pushApplicationID}:{masterSecret}"
   -v -H "Accept: application/json" -H "Content-type: application/json" 
   -X POST -d '{"message": {"action-category":"YOUR_CATEGORY_NAME", "customKey":"some value"}}'
   https://SERVER:PORT/CONTEXT/rest/sender
----

_Note:_ APNs interactive notification adds +category+ to its payload to associate a group of actions to a category of notification. As UPS already uses the name 'categories' in its payload but for a different purpose, the name 'action-category' was chosen instead.

=== Receiving interactive notifications : add category
When registering for remote notification, provide a category. To define a category, add all associated actions. Here we demo only action but you can define a list. 

Depending on your notification setup, the list of visible actions can be limited. Using _UIUserNotificationActionContextMinimal_ you can define which actions should be displayed in priority when space is limited.

[source,c]
----
- (UIMutableUserNotificationCategory*)registerActions {
    UIMutableUserNotificationAction* action = [[UIMutableUserNotificationAction alloc] init];
    action.identifier = @"YOUR_ACTION_NAME";
    action.title = @"YOUR_ACTION_NAME";
    action.activationMode = UIUserNotificationActivationModeForeground;
    action.destructive = false;
    action.authenticationRequired = false;
    
    UIMutableUserNotificationCategory* category = [[UIMutableUserNotificationCategory alloc] init];
    category.identifier = @"YOUR_CATEGORY_NAME";
    [category setActions:@[action] forContext: UIUserNotificationActionContextDefault];
    return category;
}
----

Once all actions are defined and wrapped into a category, add category to _UIUserNotificationSettings_ as shown below:

[source,c]
----
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

#ifdef __IPHONE_8_0
    UIUserNotificationCategory* category = [self registerActions];
    NSMutableSet* categories = [NSMutableSet set];
    [categories addObject:category];
    UIUserNotificationSettings* notificationSettings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:categories];
    [[UIApplication sharedApplication] registerUserNotificationSettings:notificationSettings];
    [[UIApplication sharedApplication] registerForRemoteNotifications];
#else
    [[UIApplication sharedApplication] registerForRemoteNotificationTypes: (UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert)];
#endif
----

=== Dealing with interactive notifications : add action

When an action has been selected in the interactive push notification, the callback _application:handleActionWithIdentifier:forRemoteNotification:completionHandler:_ is called. To implement your action you need to check on which action was chosen:

[source,c]
----
#ifdef __IPHONE_8_0
- (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forRemoteNotification:(NSDictionary *)userInfo completionHandler:(void(^)())completionHandler {
    if([identifier isEqualToString: @"YOUR_ACTION_NAME"]) {
      ...
      ...
    }
    completionHandler();
}
#endif
----

== You are done

That's all you need to use the _AeroGear_ project for sending, and receiving _Push Notifications_ for an iOS device.

=== A final note

When using _Push Notifications_, have in mind that it's more for signaling and once in a while notifying a client. The app has to, by Apple's guidelines, function without receving _Push Notifications_. _Remember:_ The user could have disagreed after installing your app!


